# -*- coding: utf-8 -*-
"""OnBoardandPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1U6TjimuqBij3dS7PMjvrsX4wSiCj1t1_

TensorFlow Code for Consevation X Labs Next-Generation Camera Trap

*  **Author:** Will Rawlings
*  **Date Last Modified:** August 1, 2019

Import the needed tensorflow and python libraries needed for data modification
"""

from __future__ import absolute_import, division, print_function, unicode_literals


#!pip install keras==2.2.4
import tensorflow as tf

import imageio
import os
import glob
import csv
import math
from pathlib import Path
import numpy as np
from skimage import io
from skimage import transform
from skimage import draw
from skimage import exposure
import matplotlib.pyplot as plt
import pickle
import requests
import dlib
import sys
from PIL import Image
from PIL.ExifTags import TAGS
!pip install -q tf-nightly
import cv2

"""Import the Google Drive Authorization needed to access the data folders"""

from google.colab import drive
drive.mount('/content/gdrive')
!pip install -U -q PyDrive ## you will have install for every colab session
from pydrive.auth import GoogleAuth
from pydrive.drive import GoogleDrive
from google.colab import auth
from oauth2client.client import GoogleCredentials
# 1. Authenticate and create the PyDrive client.
auth.authenticate_user()
gauth = GoogleAuth()
gauth.credentials = GoogleCredentials.get_application_default()
drive = GoogleDrive(gauth)

"""Move into My Drive, where my image folders are stored"""

cd '/content/gdrive/My Drive/'

"""Create the paths to the directories of the images, which are stored in their own folders in My Drive"""

deer_train_path= '/content/gdrive/My Drive/Internships/CXL_Internship/Deer_Dataset/deer_train/'
notDeer_train_path = '/content/gdrive/My Drive/Internships/CXL_Internship/Deer_Dataset/notDeer_train/'
test_path = '/content/gdrive/My Drive/Internships/CXL_Internship/Deer_Dataset/test_dataset/'

"""*  @param: path_in - The path to the folder of images 
*  @param: arrayName An array to store the images

Every file (or image) in the folder is read in RGB format, as BGR is the default for openCV

The image is the resized to (224,224), which is the height and width ised by most pre-trained models

The image is then appended to an array

The if statement is included because one of the images in the not deer training folder, at index 465, was not working and this bypassed that image

* @return: ArrayName The same images now populated with image data
"""

def imageAdder(path_in, arrayName):
   
    path = path_in
    i=0
    for image_path in os.listdir(path):
        if (i==465 and path_in is notDeer_train_path) or (i==195 and path_in is test_path):
            i=i+1
        else:    
            input_path = os.path.join(path, image_path)
            image = cv2.imread(input_path)
            image2 =cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
            #image = (image/127.5) - 1
            img = cv2.resize(image2,(224,224)) #crop rather than resize -keeps aspect ratio
            arrayName.append(img)
            i = i+1
    return arrayName

"""*Instantiating the arrays that will hold the training and testing images for deer and not deer*"""

deer_train = []
nDeer_train =[]
tester =[]

"""*Instantiating the arrays that will hold the training and testing images for deer and not deer*"""

deer_train = imageAdder(deer_train_path, deer_train)
nDeer_train = imageAdder(notDeer_train_path, nDeer_train)
tester = imageAdder(test_path, tester)

"""Creating the labels for the images and concatenating all the images to the same array and all the labels to the same array."""

import keras 
trainLabelsDeer = np.ones(len(deer_train))
trainLabelsNotDeer = np.zeros(len(nDeer_train))


x_total = np.concatenate((deer_train,nDeer_train))
x_total = (x_total/127.5) - 1 

y_total = np.concatenate((trainLabelsDeer, trainLabelsNotDeer))
y_total = y_total.astype(int)

#y_total = keras.utils.np_utils.to_categorical(y_total)
y_total = y_total.astype(int)
print(y_total[:10])
print(len(x_total))

tester = np.asarray(tester)
tester= (tester/127.5) -1
testLabels = np.ones(len(tester))
#testLabels= keras.utils.np_utils.to_categorical(testLabels)
testLabels = testLabels.astype(int)

print(len(testLabels))

"""*Loading the model from a saved keras file, assigning the configuration and weights to config and weights. A new model is created from these weights and configuration. This cell then assigns input_layers to the first layer for the model and output_layers to the output of the model. Both are printed to make sure they are correct.*"""

keras_file = '/content/gdrive/My Drive/models/deer_model_new.h5'
model = tf.keras.models.load_model(keras_file)
config = model.get_config()
weights = model.get_weights()
new_model = model.from_config(config)

new_model.set_weights(weights)

input_layers = new_model.input
print(new_model.input)

output_layers = new_model.output
print(new_model.output)

"""arch = model.to_json()
with open('architecture.json', 'w') as arch_file:
    arch_file.write(arch)
model.save_weights('weights.h5')

*  @param: arrayName - An array containing the images
*  @param: arrayHolder- An array to store the false predictions


Loops through every image in arrayName, predicting whether the output and label of the image.

The image is expanded to four dimensions in order to be processed by the model.
The model then predicts the image and the class number. If the prediction is correct, the class will be 0. If the class prediction is not 0, the image has been falsely identified. This image will then be appended to arrayHolder.
"""

def predictor(arrayName,  arrayHolder, label):
  
  for i in range(len(arrayName)):
    test_image_batch = arrayName[i]
    test_image_batch = test_image_batch.reshape(1,224,224,3)
    preds = model.predict_classes(test_image_batch,batch_size=1)
    probs = model.predict(test_image_batch,batch_size=1)
    if preds != label[i]:
        arrayHolder.append(arrayName[i])
    print(preds)
    print(label[i])

"""*  @param: arrayName - An array containing the images
*  @param: num - number of images shown


shows the number of images, determined by num, in the same pyplot line.

Loops until i is equal to num. The images are added to a subplot, ax. Once the for loop is broken, the plot and its subplots are shown.
"""

def showMultiple(arrayName, num):
  f = plt.figure(figsize=(30,50))
  plot_cols = num

  for i in range(plot_cols):
      ax = f.add_subplot(10,plot_cols,i+1)
      ax.axis('off')
      ax.imshow(arrayName[i])
      
  plt.show()

"""**Commented Out**

This was used to generated the false negatives and false positives predicted by the model. the method *predictor* is called for all the image arrays, which populates the arrays made to hold incorrect predictions. The length of the false prediction arrays are printed to see how many were false. These arrays are then saved in order to have that information and only do this process once. The images are shown to see what they look like, I played around with the index to show more or I used the method *showMultiple*
"""

incorrect_predictions = []
predictor(x_total,  incorrect_predictions, y_total)

print(len(incorrect_predictions))

incorrect_predictions_test = []
predictor(tester,  incorrect_predictions_test, testLabels)

print(len(incorrect_predictions_test))

keras_file = '/content/gdrive/My Drive/deer_model_WORKS.h5'
tf.keras.models.save_model(model, keras_file)

np.save("false_identification", incorrect_predictions)